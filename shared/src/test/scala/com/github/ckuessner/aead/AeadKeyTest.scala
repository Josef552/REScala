package com.github.ckuessner.aead

import com.github.ckuessner.aead.{AeadKey, ByteArray}
import org.scalatest.flatspec.AsyncFlatSpec
import org.scalatest.matchers.should.Matchers

import scala.concurrent.ExecutionContext
import scala.util.{Failure, Success}

class AeadKeyTest extends AsyncFlatSpec with Matchers {

  override implicit def executionContext: ExecutionContext = TestExecutionContext.executionContext

  "AeadHelper.ready" should "work" in {
    AeadHelper.ready().map(_ => succeed)(executionContext)
  }

  "fromRawKey" should "work with base64 encoded keys generated by Tink" in {
    val keys = Array(
      "Kd3Gx1XkDGtJk/I5xAbqQ0VtlL8YyYo+ENmfV7IvDhs=",
      "gJlYyb4ZtjIdhdhBNrVDh4lqFW+qJv4ciOFQOfNlaZY="
    )

    keys.foreach { base64Key =>
      val key        = AeadKey.fromRawKey(base64Key)
      val ciphertext = key.aeadPrimitive.encrypt("Test", "123").get
      key.aeadPrimitive.decrypt(ciphertext, "123") shouldBe Success("Test")
    }

    succeed
  }

  it should "work with base64 encoded keys generated by Libsodium.js" in {
    val keys = Array(
      "A4HzAlyQdmZJa+qKnuynLDL7XJ0hJUn/sf1sFQNZkt8=",
      "qVlUD8gkSojdvCW0pGYIP8zvYKiaMfu7UDVCyoj/Qqo="
    )

    keys.foreach { base64Key =>
      val key        = AeadKey.fromRawKey(base64Key)
      val ciphertext = key.aeadPrimitive.encrypt("Test", "123").get
      key.aeadPrimitive.decrypt(ciphertext, "123") shouldBe Success("Test")
    }

    succeed
  }

  it should "be able to load raw key" in {
    val key                  = AeadKey.generateKey
    val ciphertext           = key.aeadPrimitive.encrypt("Hello", "World").get
    val rawKey               = key.rawKeyBytes
    val importedKey: AeadKey = AeadKey.fromRawKey(rawKey)
    importedKey.aeadPrimitive.decrypt(ciphertext, "World") shouldBe Success("Hello")
  }

  "generateKey" should "provide keys that can encrypt and decrypt" in {
    val key: AeadKey = AeadKey.generateKey
    val aead         = key.aeadPrimitive
    aead.encrypt("Hello World!", "Test123") match {
      case Failure(exception) => fail("Could not encrypt with generated key", exception)
      case Success(ciphertext) =>
        aead.decrypt(ciphertext, "Test123") match {
          case Failure(exception) => fail("Could not decrypt with generated key", exception)
          case Success(plaintext) => plaintext shouldBe "Hello World!"
        }
    }
  }

}
